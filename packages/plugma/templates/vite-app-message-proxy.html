<h1 id="plugma-web-server-status">Yo</h1>
<iframe id="plugma-app-iframe" style="width: 100%; height: 100vh; border: none;"></iframe>
<script type="module">
	import { nanoid } from '/node_modules/nanoid'

	const html = document.querySelector('html');
	const status = document.getElementById('plugma-web-server-status');

	function isRunningInFigmaUI() {
		// Check if the window is running in an iframe
		const isIframe = window.parent !== window;

		// Check for Figma-specific markers in the user agent
		const isFigmaUserAgent = navigator.userAgent.includes("Figma");

		return isIframe && isFigmaUserAgent;
	}

	// Function to generate a unique message ID
	function generateMessageId(data) {
		return nanoid()
	}

	// Write to iframe so that Vite app can be mounted
	let iframe = document.getElementById("plugma-app-iframe");
	let doc = iframe.contentWindow.document;
	doc.open();
	doc.write(`<%- include("vite-app-iframe.html").replace(/\\/g, '\\\\').replace(/\//g, '\\/') %>`);
	doc.close();


	// Start web socket client
	let ws; // Declare WebSocket variable outside the function scope

	function isWebSocketOpen() {
		return ws.readyState === WebSocket.OPEN;
	}

	function connectWebSocket() {
		ws = new WebSocket('ws://localhost:9001/ws');

		// WebSocket open event
		ws.onopen = function () {
			status.textContent = 'Server is running';
			if (isRunningInFigmaUI()) {
				iframe.style.display = "none"
			}
			else {
				status.style.display = "none"
			}
		};

		// Handle WebSocket errors
		ws.onerror = function () {
			status.textContent = 'Error connecting to server';
		};

		// Handle WebSocket closure and try to reconnect
		ws.onclose = function () {
			status.textContent = 'Server is not running. Reconnecting...';
			setTimeout(function () {
				connectWebSocket(); // Attempt to reconnect
			}, 2000);
		};
	}

	// Initial WebSocket connection
	connectWebSocket();


	// Any messages sent from UI need to pass up to the parent (main code), but not if running headless in browser
	if (isRunningInFigmaUI()) {



		// Apply Figma styles to intermediate space
		window.addEventListener('message', (event) => {
			const message = event.data;

			if (message.type === "FIGMA_HTML_CLASSES") {
				// console.log('Message received:', message);
				html.className = message.data
			}
			if (message.type === "FIGMA_STYLES") {
				const styleSheet = document.createElement("style");
				styleSheet.type = "text/css";
				styleSheet.innerText = message.data;

				// Append the style tag to the head
				document.head.appendChild(styleSheet);
			}

			// Forward styles (and other messages) to plugin UI
			if (event.origin === "null") {

				iframe.contentWindow.postMessage({
					pluginMessage: event.data
				}, "*")
			}
		});





		// Track messages that have already been processed
		const processedMessages = new Set();



		window.onmessage = (event) => {

			if (!isWebSocketOpen()) {

				// Forward up to parent if it comes from "plugma-inner-iframe"
				if (event.origin !== "https://www.figma.com") {
					// console.log("post upwards")
					parent.postMessage(event.data, "*")
				}

				// Forward down to inner iframe if it comes from "Inner Plugin Iframe"
				if (event.origin === "https://www.figma.com") {
					// console.log("post downwards")
					iframe.contentWindow.postMessage(event.data, "*")
				}
			}
			else {
				// Listen for messages from parent and forward to web socket server
				// ws.send(JSON.stringify(event.data));

				const messageData = event.data;
				const messageId = generateMessageId(messageData); // Use the same ID generation function

				// Check if this message has already been processed
				// if (!processedMessages.has(messageId)) {
				// Add message to the processed set
				processedMessages.add(messageId);

				// Forward the message to WebSocket server
				if (ws.readyState === WebSocket.OPEN) {
					ws.send(JSON.stringify({ messageId, data: messageData }));
				}
				// }
			}


		};

		// Forward up to parent if it comes from web socket server
		ws.onmessage = (wsEvent) => {
			const serverMessage = JSON.parse(wsEvent.data);
			const webSocketMessage = JSON.parse(serverMessage.webSocketMessage)


			// Check if this message has already been processed
			if (!processedMessages.has(webSocketMessage.messageId)) {

				// Add the message to the processed set
				processedMessages.add(webSocketMessage.messageId);

				// Forward the message to the parent
				parent.postMessage(webSocketMessage.data, "*");
			}
		};


	}
	else {


		// const ws = new WebSocket('ws://localhost:9001/ws');

		// Track messages that have already been processed
		const processedMessages = new Set();

		// Listen for messages from iframe
		window.onmessage = (event) => {
			// Forward the message to websocket server
			const messageData = event.data;
			const messageId = generateMessageId(messageData);



			// Check if this message has already been processed
			if (!processedMessages.has(messageId)) {
				// Add message to the processed set


				if (!processedMessages.has(messageId)) {
					processedMessages.add(messageId);
					// Forward the message to WebSocket server
					if (ws.readyState === WebSocket.OPEN) {
						ws.send(JSON.stringify({ messageId, data: messageData }));
					} else {
						console.warn("WebSocket connection is not open");
					}
				}
			}

		};

		ws.onmessage = (event) => {
			let message = JSON.parse(event.data)
			let webSocketMessage = JSON.parse(message.webSocketMessage)
			if (!processedMessages.has(webSocketMessage.messageId)) {
				iframe.contentWindow.postMessage(webSocketMessage.data, "*")
			}
		}
	}
</script>

<style>
	html {
		/* keep background transparent to avoid flicker when changing theme in dev mode */
		color: var(--figma-color-text);
	}
</style>
